#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include "mini.h"
#include "libft.h"

extern char **environ;

int		main(void)
{
	t_parse	pars;
	char	*command;
	char	*prompt;

	ft_putchar_fd(prompt, 1);
	get_next_line(0, &command);
	이렇게 하면 command에 라인이 담겨지겠죠?
	이래서 이거를 가지고 이제 파싱을 하는 거임
	command를 parsing해서 다 예쁘게 담는거임
	그러면 이제 pars.pro_lst->cmd_lst->content 이런 애들에 담겨있겠죠?
	그러면 그거를 첫번째꺼를 command라 하고 그 이후의 애들을 배열에 담아서 넘겨줘야겠죠?
	아 얘를 배열에 담아야하네.. 아까 채욱씨가 말한거죠 어제 하던 그거
	그냥 첨부터 포인터 배열로 하면 안됐나? 흐음.. 왜 알 수 없죠? 근데 첨부터 다 알지 않아요?
	다는 아닌데 첨에 raw는 그냥 | ; 이런걸로 끊은 거잖아요? 그리고 raw_lst는 이제 스페이스별로 끊은거고?
	그러면 거기서 대충 몇개인지 각 나오지 않아여? 음 근데 '' 이런것들은 없는 취급 해줘야해서 리스트 삭제하는 작업도 해줘야할 것 같음
	아 그것도 괜찮죠 그러면 cmd_lst->content가 null이겟네요?
	그러면 그거를 내일 해보고여
	그거를 배열에 담아서 ㄱㄷ생각중
	chlid = fork(); 이거 하고
	pid = wait어쩌구(&state) <이거는 wait 관련함수가 4개나 되던데 좀 더 자세히 알아보고 적당한거 골라서 쓸게요
	그래서 if (child가 0이면 새로 생긴 자식ㄱ새끼)니까 execve해서 그거 실행시켜주면 될 것 같고여 근데 문제는 음
	빌트인을 쓸 때랑 아닐때랑 다르죠? 빌트인이 아닐 때만 저걸 하는거죠?
	암튼 그러면 그걸 또 경우를 나눠서 만들면 되겠고?
	while은 계속 true로 해줘서 대기상태를 만들어야겟네요?
	그리고 시그널을 어떻게 줄지? 네ㅇㅎ
	암튼 그러고 또 필요한게 있었는데 그게 뭐였나면 생각이 안남..아맞다 리디렉션이랑 파이프!
	그 부분은 제가 좀 더 연구해볼 필요가 있을 것 같아서 그 부분은 좀 뒤로 미루고 메인부터 처리해볼까 생각중이에요
	근데 공부하고 나면 생각보다 간단할 것 같음
	넹 그래서 지금 궁금한게 파이프처리를 하면 이게 동시에 되는거잖아요?
	그러면... 자식 프로세스를 여러개 만들어야하는거겠죠? ㄹㅇ 그럴 것 같네요
	그러면 일단 파싱부터 해야겠네요 프로세스 몇개를 돌릴지
	그러면 일단 최우선적으로 배열 옮기는 작업을 걍 지금 해버릴까요? 네 네 밖으로?
	네
	
}